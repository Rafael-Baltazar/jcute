import org.jmlspecs.ajmlrac.runtime.*;


public privileged aspect AspectJMLRac_pt_ulisboa_tecnico_Main {

 declare precedence: AspectJMLRac_*, *;


  /** Generated by AspectJML to check the normal postcondition of
   * method add. */
  after (final pt.ulisboa.tecnico.Main object$rac, final int x, final int y) returning (final int rac$result) :
     (execution(int pt.ulisboa.tecnico.Main.add(int, int))) && this(object$rac) && args(x, y) {
       String nPostErrorMsg =  "";
       String evalErrorMsg = "";
       boolean rac$b = true;
         nPostErrorMsg =  "by method pt.ulisboa.tecnico.Main.add regarding specifications at \nFile \"pt.ulisboa.tecnico.Main.java\", line 6, character 26 (pt.ulisboa.tecnico.Main.java:6), and \nby method pt.ulisboa.tecnico.Main.add regarding code at \nFile \"pt.ulisboa.tecnico.Main.java\", line 10 (pt.ulisboa.tecnico.Main.java:10)"+", when \n"+"\t\'x\' is "+x+"\n\t\'y\' is "+y;
         evalErrorMsg = "Invalid expression in \"pt.ulisboa.tecnico.Main.java\" by method pt.ulisboa.tecnico.Main.add regarding specifications at \nline 6, character 26 (pt.ulisboa.tecnico.Main.java:6)"+", when \n"+"\t\'x\' is "+x+"\n\t\'y\' is "+y+"\nCaused by: ";
       if (((x > 0) && (y > 0))){
         try {
           rac$b = (rac$result == (x + y));
         } catch (JMLNonExecutableException rac$nonExec) {
            rac$b = false;
         } catch (Throwable rac$cause) {
            if(rac$cause instanceof JMLAssertionError) {
              throw (JMLAssertionError) rac$cause;
            }
            else {
              throw new JMLEvaluationError(evalErrorMsg + rac$cause);
            }
         }
        JMLChecker.checkNormalPostcondition(rac$b, nPostErrorMsg, -1, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".add(int, int)");
       }

     }

  /** Generated by AspectJML to check the exceptional postcondition of
   * method add. */
  after (final pt.ulisboa.tecnico.Main object$rac, final int x, final int y) throwing (Throwable rac$e) :
     (execution(int pt.ulisboa.tecnico.Main.add(int, int))) && this(object$rac) && args(x, y) {
           JMLChecker.rethrowJMLAssertionError(rac$e, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".add(int, int)");
           boolean rac$b = true;
           String rac$ErrorMsg = "";

  		   if (rac$b && ((x > 0) && (y > 0))) {
  		     if (rac$e instanceof java.lang.RuntimeException) {
  			   java.lang.RuntimeException jml$ex = (java.lang.RuntimeException) rac$e;
  			   boolean rac$b0 = true;
  			   try{			     
  			     rac$b0 = true;
  			   }   catch (JMLNonExecutableException rac$nonExec) {
  			     throw new JMLEvaluationError("Invalid Expression in \"pt.ulisboa.tecnico.Main.java\" by method pt.ulisboa.tecnico.Main.add\nCaused by: "+rac$e);
  			   }
  			   if(!rac$b0) {
  			     if(rac$ErrorMsg.equals("")) {
  			       rac$ErrorMsg = "jml$ex";
  			     }
  			     else {
  			       rac$ErrorMsg += " and jml$ex";
  			     }
  			   }
  			   rac$b = rac$b && rac$b0;
           if(rac$ErrorMsg.indexOf("and") >= 0 ){
             rac$ErrorMsg += " are ";
           }
           else{
             rac$ErrorMsg += " is ";
           }
               JMLChecker.checkExceptionalPostcondition(rac$b,"by method pt.ulisboa.tecnico.Main.add regarding code at \nFile \"pt.ulisboa.tecnico.Main.java\", line 10 (pt.ulisboa.tecnico.Main.java:10)"+"\n\t"+rac$ErrorMsg+rac$e, "jml$ex", true, -1, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".add(int, int)", rac$e);
  		 }
  		   }
  	 }

  /** Generated by AspectJML to check the exceptional postcondition of
   * method main. */
   after (final java.lang.String[] args) throwing (Throwable rac$e) :
     execution(static void pt.ulisboa.tecnico.Main.main(java.lang.String[])) && args(args) {
           JMLChecker.rethrowJMLAssertionError(rac$e, "pt.ulisboa.tecnico.Main.main(java.lang.String[])");
           boolean rac$b = true;
           String rac$ErrorMsg = "";

  		   if (true) {
  		     if (rac$e instanceof java.lang.RuntimeException) {
  			   java.lang.RuntimeException jml$ex = (java.lang.RuntimeException) rac$e;
  			   boolean rac$b0 = true;
  			   try{			     
  			     rac$b0 = true;
  			   }   catch (JMLNonExecutableException rac$nonExec) {
  			     throw new JMLEvaluationError("Invalid Expression in \"pt.ulisboa.tecnico.Main.java\" by method pt.ulisboa.tecnico.Main.main\nCaused by: "+rac$e);
  			   }
  			   if(!rac$b0) {
  			     if(rac$ErrorMsg.equals("")) {
  			       rac$ErrorMsg = "jml$ex";
  			     }
  			     else {
  			       rac$ErrorMsg += " and jml$ex";
  			     }
  			   }
  			   rac$b = rac$b && rac$b0;
           if(rac$ErrorMsg.indexOf("and") >= 0 ){
             rac$ErrorMsg += " are ";
           }
           else{
             rac$ErrorMsg += " is ";
           }
               JMLChecker.checkExceptionalPostcondition(rac$b,"by method pt.ulisboa.tecnico.Main.main regarding code at \nFile \"pt.ulisboa.tecnico.Main.java\""+"\n\t"+rac$ErrorMsg+rac$e, "jml$ex", true, -1, "pt.ulisboa.tecnico.Main.main(java.lang.String[])", rac$e);
  		 }
  		   }
  	 }



  /** Generated by AspectJML to check the precondition of
   * method add. */
  before (final pt.ulisboa.tecnico.Main object$rac, final int x, final int y) :
     (execution(int pt.ulisboa.tecnico.Main.add(int, int))) && 
     this(object$rac) && args(x, y) {
       String preErrorMsg = "by method pt.ulisboa.tecnico.Main.add regarding specifications at \nFile \"pt.ulisboa.tecnico.Main.java\", [spec-case]: line 5, character 20 (pt.ulisboa.tecnico.Main.java:5), and \nby method pt.ulisboa.tecnico.Main.add regarding code at \nFile \"pt.ulisboa.tecnico.Main.java\", line 10 (pt.ulisboa.tecnico.Main.java:10)"+", when \n"+"\t\'x\' is "+x+"\n\t\'y\' is "+y;
       String evalErrorMsg = "Invalid expression in \"pt.ulisboa.tecnico.Main.java\" by method pt.ulisboa.tecnico.Main.add regarding specifications at \n[spec-case]: line 5, character 20 (pt.ulisboa.tecnico.Main.java:5)"+", when \n"+"\t\'x\' is "+x+"\n\t\'y\' is "+y+"\nCaused by: ";
       boolean rac$b = true;
       try {
         rac$b = ((x > 0) && (y > 0));
       } catch (JMLNonExecutableException rac$nonExec) {
         rac$b = false;
       } catch (Throwable rac$cause) {
         if(rac$cause instanceof JMLAssertionError) {
           throw (JMLAssertionError) rac$cause;
         }
         else {
           throw new JMLEvaluationError(evalErrorMsg + rac$cause);
         }
       }
       boolean canThrow = false;
       JMLChecker.checkPrecondition(rac$b, canThrow, preErrorMsg, -1, object$rac.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(object$rac))+".add(int, int)");

     }

  /** Generated by AspectJML to check the precondition of
   * method main. */
  before (final java.lang.String[] args) :
     execution(static void pt.ulisboa.tecnico.Main.main(java.lang.String[])) && args(args) {
       String preErrorMsg = "by method pt.ulisboa.tecnico.Main.main regarding code at \nFile \"pt.ulisboa.tecnico.Main.java\""+", when \n"+"\t\'args\' is "+args+ ", when \n"+"\t\'args\' is "+args;
       String evalErrorMsg = "Invalid expression in \"pt.ulisboa.tecnico.Main.java\"\nCaused by: ";
       boolean rac$b = true;
       try {
         rac$b = (args != null);
       } catch (JMLNonExecutableException rac$nonExec) {
         rac$b = false;
       } catch (Throwable rac$cause) {
         if(rac$cause instanceof JMLAssertionError) {
           throw (JMLAssertionError) rac$cause;
         }
         else {
           throw new JMLEvaluationError(evalErrorMsg + rac$cause);
         }
       }
       boolean canThrow = true;
       JMLChecker.checkPrecondition(rac$b, canThrow, preErrorMsg, -1, "pt.ulisboa.tecnico.Main.main(java.lang.String[])");

     }



  /** Generated by AspectJML to enable modular signals_only checking (XCS enabled) */
    after(final pt.ulisboa.tecnico.Main object$rac): (execution( * pt.ulisboa.tecnico.Main+.*(..))
            || execution(pt.ulisboa.tecnico.Main+.new(..))) && 
     this(object$rac) {
     JMLChecker.hasAnyThrownExceptionalPostconditionSignalsOnly();
    }

  /** Generated by AspectJML to enhance error reporting (Execution Site enabled) */
    after() throwing (Throwable rac$e): (execution( * pt.ulisboa.tecnico.Main+.*(..))
            || execution(pt.ulisboa.tecnico.Main+.new(..))){
      JMLChecker.hideAjmlSpecificStackTrace(rac$e);
    }

  /** Generated by AspectJML to enhance precondition checking */
  public static aspect UtilPreconditionChecking_Main{
    before(): (execution( * pt.ulisboa.tecnico.Main+.*(..))
            || execution(pt.ulisboa.tecnico.Main+.new(..))){
      JMLChecker.hasAnyThrownPrecondition();
    }
  }
}
